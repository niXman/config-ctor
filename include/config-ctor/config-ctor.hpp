
// Copyright (c) 2014-2019 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of CONFIG-CTOR(https://github.com/niXman/config-ctor) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef __config_ctor__config_ctor_hpp
#define __config_ctor__config_ctor_hpp

#include <config-ctor/flatjson.hpp>

#include <boost/tti/has_member_function.hpp>

#include <boost/preprocessor/cat.hpp>
#include <boost/preprocessor/comparison/greater_equal.hpp>
#include <boost/preprocessor/control/if.hpp>
#include <boost/preprocessor/stringize.hpp>
#include <boost/preprocessor/punctuation/comma_if.hpp>
#include <boost/preprocessor/seq/for_each_i.hpp>
#include <boost/preprocessor/tuple/size.hpp>
#include <boost/preprocessor/tuple/elem.hpp>

#include <string>
#include <iosfwd>
#include <fstream>
#include <stdexcept>

#include <cstdlib>
#include <cstdint>

#ifdef _WIN32
#   include <direct.h>
#else
#   include <unistd.h>
#endif // _WIN32

/***************************************************************************/

namespace config_ctor {
namespace details {

BOOST_TTI_HAS_MEMBER_FUNCTION(after_read)
BOOST_TTI_HAS_MEMBER_FUNCTION(before_write)

template<bool>
struct call_after_read_proxy {
    template<typename T>
    static void call(T&) {}
};

template<>
struct call_after_read_proxy<true> {
    template<typename T>
    static void call(T& o) { o.after_read(o); }
};

template<bool>
struct call_before_write_proxy {
    template<typename T>
    static void call(const T&) {}
};

template<>
struct call_before_write_proxy<true> {
    template<typename T>
    static void call(const T& o) { const_cast<T&>(o).before_write(const_cast<T&>(o)); }
};

std::string get_procpath();
std::string get_procname();

/***************************************************************************/

template<typename>
struct is_bool: std::false_type
{};

template<>
struct is_bool<bool>: std::true_type
{};

template<typename T>
struct is_integral: std::integral_constant<bool, std::is_integral<T>::value && !is_bool<T>::value>
{};

template<typename T>
struct is_floating: std::is_floating_point<T>
{};

template<typename T>
struct is_string: std::is_same<T, std::string>
{};

template<typename T>
struct is_null: std::is_null_pointer<T>
{};

template<typename T>
struct is_simple_type: std::integral_constant<
         bool
        ,is_bool<T>::value ||
         is_integral<T>::value ||
         is_floating<T>::value ||
         is_string<T>::value ||
         is_null<T>::value
    >
{};

template<typename T>
struct is_config_ctor_type: std::integral_constant<
         bool
        ,!is_simple_type<T>::value &&
         std::is_constructible<T, const flatjson::fjson &>::value
    >
{};

/***************************************************************************/

// bool
template<typename T>
T get_value(
     T *
    ,const char *key
    ,const flatjson::fjson &cfg
    ,const char *default_value
    ,typename std::enable_if<is_bool<T>::value>::type* = nullptr)
{
    if ( !default_value ) {
        return cfg.at(key).to_bool();
    }

    return !cfg.contains(key) ? (std::strcmp(default_value, "true") == 0) : cfg.at(key).to_bool();
}

// integrals
template<typename T>
T get_value(
     T *
    ,const char *key
    ,const flatjson::fjson &cfg
    ,const char *default_value
    ,typename std::enable_if<is_integral<T>::value>::type* = nullptr)
{
    std::string str;
    if ( !default_value ) {
        str = cfg.at(key).to_string();
    } else {
        str = !cfg.contains(key)
            ? default_value
            : cfg.at(key).to_string()
        ;
    }

    std::int64_t mult = 1;
    switch ( str.back() ) {
        case 't': case 'T': mult *= 1024; // fallthrough
        case 'g': case 'G': mult *= 1024; // fallthrough
        case 'm': case 'M': mult *= 1024; // fallthrough
        case 'k': case 'K': mult *= 1024; // fallthrough

        str.pop_back();
    }

    if ( std::is_unsigned<T>::value ) {
        return static_cast<T>(std::stoul(str) * mult);
    }

    return static_cast<T>(std::stol(str) * mult);
}

// floating
template<typename T>
T get_value(
     T *
    ,const char *key
    ,const flatjson::fjson &cfg
    ,const char *default_value
    ,typename std::enable_if<is_floating<T>::value>::type* = nullptr)
{
    if ( !default_value ) {
        return cfg.at(key).to<T>();
    }

    return !cfg.contains(key)
        ? (flatjson::details::conv_to<T>(default_value, std::strlen(default_value)))
        : cfg.at(key).to<T>()
    ;
}

template<typename Iterator, typename Pred>
Iterator find_if(Iterator beg, Iterator end, Pred pred) {
    for ( ; beg != end ; ++beg ) {
        if ( pred(*beg) ) {
            return beg;
        }
    }

    return end;
}

// string
template<typename T>
T get_value(
     T *
    ,const char *key
    ,const flatjson::fjson &cfg
    ,const char *default_value
    ,typename std::enable_if<is_string<T>::value>::type* = nullptr)
{
    std::string res;
    if ( !default_value ) {
        res = cfg.at(key).to_string();
    } else {
        res = !cfg.contains(key)
            ? default_value
            : cfg.at(key).to_string()
        ;
    }

    static auto get_home = []() -> std::string {
    #ifdef _WIN32
        return ::getenv("USERPROFILE");
    #elif defined(__linux__) || defined(__APPLE__)
        return ::getenv("HOME");
    #else
    #   error UNKNOWN HOST
    #endif
    };
    static auto get_user = []() -> std::string {
    #ifdef _WIN32
        return ::getenv("USERNAME");
    #elif defined(__linux__) || defined(__APPLE__)
        return ::getenv("USER");
    #else
    #   error UNKNOWN HOST
    #endif
    };
    static auto get_cwd  = []() -> std::string {
        char buf[1024];
        return ::getcwd(buf, sizeof(buf));
    };
    static auto get_temp = []() -> std::string {
        if (const char *temp = ::getenv("TMPDIR")) {
            return temp;
        } else if (const char *temp = ::getenv("TEMP")) {
            return temp;
        } else if (const char *temp = ::getenv("TMP")) {
            return temp;
        }
        return "/tmp";
    };
    static auto get_pid  = []() -> std::string {
        int pid = ::getpid();
        return std::to_string(pid);
    };
    static auto get_path = []() -> std::string { return ::getenv("PATH"); };
    static auto get_proc_name = []() -> std::string { return details::get_procname(); };
    static auto get_proc_path = []() -> std::string { return details::get_procpath(); };
    static auto replace = [](std::string &str, const std::string &ostr, const std::string &nstr) {
        std::string::size_type pos = 0u;
        while ( (pos = str.find(ostr, pos)) != std::string::npos ) {
            str.replace(pos, ostr.length(), nstr);
            pos += nstr.length();
        }
    };

    static auto trim = [](std::string &s) {
        if ( s.empty() ) return;

        static auto ltrim = [](std::string &s) {
            auto p = ::config_ctor::details::find_if(s.begin(), s.end(), [](int ch) { return !std::isspace(ch); });
            s.erase(s.begin(), p);
        };
        static auto rtrim = [](std::string &s) {
            auto p = ::config_ctor::details::find_if(s.rbegin(), s.rend(), [](int ch) { return !std::isspace(ch); });
            s.erase(p.base(), s.end());
        };

        ltrim(s);
        rtrim(s);
    };

    using pair_t = std::pair<const char *, std::string(*)()>;
    static const pair_t map[] = {
         {"{HOME}", get_home}
        ,{"{USER}", get_user}
        ,{"{CWD}", get_cwd}
        ,{"{TEMP}", get_temp}
        ,{"{PID}", get_pid}
        ,{"{PATH}", get_path}
        ,{"{PROC}", get_proc_name}
        ,{"{PROCPATH}", get_proc_path}
    };
    for ( const auto &it: map ) {
        replace(res, it.first, it.second());
    }

    // process {GETENV(var)} && {GETENV(var, default)}
    static const char getenv_pref[]   = "{GETENV(";
    static const auto getenv_pref_len = sizeof(getenv_pref)-1;
    static const char getenv_suff[]   = ")}";
    static const auto getenv_suff_len = sizeof(getenv_suff)-1;

    auto beg = res.find(getenv_pref, 0, getenv_pref_len);
    if ( beg != std::string::npos ) {
        auto end = res.find(getenv_suff, beg, getenv_suff_len);
        auto body = res.substr(beg+getenv_pref_len, end-(beg+getenv_pref_len));
        auto comma = body.find(',');
        std::string env, def;
        if ( comma != std::string::npos ) {
            env = body.substr(0, comma);
            def = body.substr(comma+1);
        } else {
            env = body;
        }
        trim(env);
        trim(def);

        const char *penv = ::getenv(env.c_str());
        if ( penv ) {
            res.replace(beg, end+getenv_suff_len-beg, penv);
        } else {
            if ( !def.empty() ) {
                res.replace(beg, end+getenv_suff_len-beg, def.c_str());
            } else {
                res.replace(beg, end+getenv_suff_len-beg, "<NULL>");
            }
        }
    }

    return res;
}

// any config-ctor type
template<typename T>
T get_value(
     T *
    ,const char *key
    ,const flatjson::fjson &cfg
    ,const char *default_value
    ,typename std::enable_if<is_config_ctor_type<T>::value>::type* = nullptr)
{
    if ( !default_value ) {
        return T{cfg.at(key)};
    }

    const flatjson::fjson json = !cfg.contains(key)
        ? flatjson::fjson{default_value}
        : cfg.at(key)
    ;

    return T{json};
}

/***************************************************************************/

template<typename T>
struct is_stl_container_like {
    template<typename A>
    static constexpr bool test(
         A * pt
        ,A const * cpt = nullptr
        ,decltype(pt->begin()) * = nullptr
        ,decltype(pt->end()) * = nullptr
        ,decltype(cpt->begin()) * = nullptr
        ,decltype(cpt->end()) * = nullptr
        ,typename A::iterator * = nullptr
        ,typename A::const_iterator * = nullptr)
    {
        using iterator = typename A::iterator;
        using const_iterator = typename A::const_iterator;

        return
            std::is_same<decltype(pt->begin()),iterator>::value &&
            std::is_same<decltype(pt->end()),iterator>::value &&
            std::is_same<decltype(cpt->begin()),const_iterator>::value &&
            std::is_same<decltype(cpt->end()),const_iterator>::value
        ;
    }

    template<typename A>
    static constexpr bool test(...) { return false; }

    static const bool value = test<typename std::remove_const<T>::type>(nullptr);
};

template<
     typename T
    ,typename = typename std::enable_if<is_config_ctor_type<T>::value>::type
>
std::ostream& operator<< (std::ostream &os, const T &v) {
    return v.dump(os);
}

template<typename Iterator, std::size_t N>
void out_for_each(std::ostream &os, Iterator beg, Iterator end, const char(&delim)[N]) {
    for ( ; beg != end; ++beg ) {
        using value_type = typename std::iterator_traits<Iterator>::value_type;
        if ( is_string<value_type>::value ) {
            os << '\"';
        }

        os << *beg;

        if ( is_string<value_type>::value ) {
            os << '\"';
        }

        if ( std::next(beg) != end ) {
            os.write(delim, N - 1);
        }
    }
}

template<typename C>
void get_value_container_proxy(
     C &c
    ,const flatjson::fjson &json
    ,typename std::enable_if<is_simple_type<typename C::value_type>::value>::type* = nullptr)
{
    if ( !json.is_simple_type() ) {
        throw std::runtime_error("SIMPLE type expected!");
    }

    c.insert(c.end(), json.to<typename C::value_type>());
}

template<typename C>
void get_value_container_proxy(
     C &c
    ,const flatjson::fjson &json
    ,typename std::enable_if<is_config_ctor_type<typename C::value_type>::value>::type* = nullptr)
{
    c.push_back(typename C::value_type{json});
}

template<typename T>
T get_value(
     T *
    ,const char *key
    ,const flatjson::fjson &cfg
    ,const char *default_value
    ,typename std::enable_if<is_stl_container_like<T>::value && !is_string<T>::value>::type* = nullptr)
{
    flatjson::fjson json;

    if ( !default_value ) {
        json = cfg.at(key);
    } else {
        json = !cfg.contains(key)
            ? flatjson::fjson{default_value}
            : cfg.at(key)
        ;
    }

    if ( !json.is_array() ) {
        throw std::runtime_error("ARRAY type expected!");
    }

    T res;
    for ( std::size_t idx = 0u; idx < json.size(); ++idx ) {
        const auto it = json.at(idx);
        get_value_container_proxy(res, it);
    }

    return res;
}

/***************************************************************************/

template<typename T>
void write_value(
     std::ostream &os
    ,const T &v
    ,typename std::enable_if<is_bool<T>::value>::type* = nullptr)
{
    os << std::boolalpha << v;
}

template<typename T>
void write_value(
     std::ostream &os
    ,const T &v
    ,typename std::enable_if<is_integral<T>::value || is_floating<T>::value>::type* = nullptr)
{
    os << v;
}

template<typename T>
void write_value(
    std::ostream &os
    ,const T &v
    ,typename std::enable_if<is_string<T>::value>::type* = nullptr)
{
    os << '\"' << v.c_str() << '\"';
}

template<typename T>
void write_value(
     std::ostream &os
    ,const T &v
    ,typename std::enable_if<is_config_ctor_type<T>::value>::type* = nullptr)
{
    v.dump(os);
}

template<typename T>
void write_value(
     std::ostream &os
    ,const T &v
    ,typename std::enable_if<is_stl_container_like<T>::value && !is_string<T>::value>::type* = nullptr)
{
    os << '[';
    out_for_each(os, v.begin(), v.end(), ", ");
    os << ']';
}

/***************************************************************************/

inline void check_config_keys_for_object_keys(
     const char *configobj
    ,const flatjson::fjson &json
    ,const char **arr)
{
    auto keys = json.get_keys();
    for ( const auto &it: keys ) {
        // because I won't include algorithms in this header %)
        bool found = false;
        for ( const char **ait = arr; *ait; ++ait ) {
            if ( 0 == std::strncmp(it.data(), *ait, it.size()) ) {
                found = true;
                break;
            }
        }
        if ( !found ) {
            std::string msg = "config-ctor: config file has \"";
            msg.append(it.data(), it.size());
            msg += "\" key that doesn't exists in the \"";
            msg += configobj;
            msg += "\" object";
            throw std::runtime_error(msg);
        }
    }
}

} // ns details
} // ns config_ctor

/***************************************************************************/

#define __CONFIG_CTOR__WRAP_SEQUENCE_X(...) \
    ((__VA_ARGS__)) __CONFIG_CTOR__WRAP_SEQUENCE_Y
#define __CONFIG_CTOR__WRAP_SEQUENCE_Y(...) \
    ((__VA_ARGS__)) __CONFIG_CTOR__WRAP_SEQUENCE_X

#define __CONFIG_CTOR__WRAP_SEQUENCE_X0
#define __CONFIG_CTOR__WRAP_SEQUENCE_Y0

/***************************************************************************/

#define __CONFIG_CTOR__GENERATE_MEMBERS(unused, data, idx, elem) \
    BOOST_PP_TUPLE_ELEM(0, elem) /* type */ BOOST_PP_TUPLE_ELEM(1, elem) /* var name */ ;

#define __CONFIG_CTOR__INIT_MEMBERS_WITH_DEFAULT(...) \
    BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(2, __VA_ARGS__))

#define __CONFIG_CTOR__INIT_MEMBERS_WITHOUT_DEFAULT(...) \
    nullptr

#define __CONFIG_CTOR__INIT_MEMBERS__BODY(varname, withdefault, elem) \
    varname{ \
        ::config_ctor::details::get_value( \
             &varname \
            ,BOOST_PP_STRINGIZE(varname)  \
            ,json \
            ,BOOST_PP_IF( \
                 withdefault \
                ,__CONFIG_CTOR__INIT_MEMBERS_WITH_DEFAULT \
                ,__CONFIG_CTOR__INIT_MEMBERS_WITHOUT_DEFAULT \
            )(elem) \
        ) \
    }

#define __CONFIG_CTOR__INIT_MEMBERS__COLON_CASE(varname, withdefault, elem) \
    :__CONFIG_CTOR__INIT_MEMBERS__BODY(varname, withdefault, elem)

#define __CONFIG_CTOR__INIT_MEMBERS__COMMA_CASE(varname, withdefault, elem) \
    ,__CONFIG_CTOR__INIT_MEMBERS__BODY(varname, withdefault, elem)

#define __CONFIG_CTOR__INIT_MEMBERS(unused, data, idx, elem) \
    BOOST_PP_IF( \
         idx \
        ,__CONFIG_CTOR__INIT_MEMBERS__COMMA_CASE \
        ,__CONFIG_CTOR__INIT_MEMBERS__COLON_CASE \
    )( \
         BOOST_PP_TUPLE_ELEM(1, elem) \
        ,BOOST_PP_GREATER_EQUAL(BOOST_PP_TUPLE_SIZE(elem), 3)\
        ,elem \
    )

#define __CONFIG_CTOR__ENUM_MEMBERS(unused, data, idx, elem) \
    BOOST_PP_IF(idx, os << "   ,";, os << "    ";) \
    os << "\"" BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(1, elem)) "\":"; \
    ::config_ctor::details::write_value(os, BOOST_PP_TUPLE_ELEM(1, elem));

/***************************************************************************/

#define __CONFIG_CTOR__ENUM_WRITE_MEMBERS(unused, data, idx, elem) \
    BOOST_PP_IF(idx, os << "   ,";, os << "    ";) \
    os << "\"" BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(1, elem)) "\":"; \
    ::config_ctor::details::write_value(os, cfg.BOOST_PP_TUPLE_ELEM(1, elem)); \
    os << '\n';

#define __CONFIG_CTOR__GENERATE_MEMBERS_STR_NAMES(unused0, unused1, idx, elem) \
    BOOST_PP_COMMA_IF(idx) \
        BOOST_PP_STRINGIZE(BOOST_PP_TUPLE_ELEM(1, elem))

#define __CONFIG_CTOR__GENERATE_KEY_CHECKING(cfgname, keys, ptree, seq) { \
    static const char *keys[] = { \
        BOOST_PP_SEQ_FOR_EACH_I( \
             __CONFIG_CTOR__GENERATE_MEMBERS_STR_NAMES \
            ,~ \
            ,seq \
        ) \
        ,nullptr \
    }; \
    config_ctor::details::check_config_keys_for_object_keys( \
         cfgname \
        ,ptree \
        ,keys \
    ); \
}

#define __CONFIG_CTOR__GENERATE_CTOR_ARGS(unused, data, idx, elem) \
    BOOST_PP_COMMA_IF(idx) \
        BOOST_PP_TUPLE_ELEM(0, elem) arg##idx

#define __CONFIG_CTOR__GENERATE_INIT_LIST_COMMA_CASE(membername, argname) \
    ,membername{std::move(argname)}

#define __CONFIG_CTOR__GENERATE_INIT_LIST_COLON_CASE(membername, argname) \
    :membername{std::move(argname)}

#define __CONFIG_CTOR__GENERATE_INIT_LIST(unused, data, idx, elem) \
    BOOST_PP_IF( \
         idx \
        ,__CONFIG_CTOR__GENERATE_INIT_LIST_COMMA_CASE \
        ,__CONFIG_CTOR__GENERATE_INIT_LIST_COLON_CASE \
    )( \
         BOOST_PP_TUPLE_ELEM(1, elem) \
        ,arg##idx \
    )

/***************************************************************************/

#define __CONFIG_CTOR__GENERATE_STRUCT(name, seq, ...) \
    struct name { \
        __VA_ARGS__ /* user code will expanded here */ \
        \
        name() = default; \
        name(const name &) = default; \
        name(name &&) = default; \
        name& operator= (const name &) = default; \
        name& operator= (name &&) = default; \
        \
        name(const ::flatjson::fjson &json) \
            BOOST_PP_SEQ_FOR_EACH_I( \
                 __CONFIG_CTOR__INIT_MEMBERS \
                ,name \
                ,seq \
            ) \
        {} \
        \
        name( \
            BOOST_PP_SEQ_FOR_EACH_I( \
                 __CONFIG_CTOR__GENERATE_CTOR_ARGS \
                ,~ \
                ,seq \
            ) \
        ) \
            BOOST_PP_SEQ_FOR_EACH_I( \
                 __CONFIG_CTOR__GENERATE_INIT_LIST \
                ,~ \
                ,seq \
            ) \
        {} \
        \
        BOOST_PP_SEQ_FOR_EACH_I( \
             __CONFIG_CTOR__GENERATE_MEMBERS \
            ,~ \
            ,seq \
        ) \
        \
        static name read(std::istream &is) { \
            std::string str( \
                 (std::istreambuf_iterator<char>(is)) \
                ,std::istreambuf_iterator<char>()) \
            ; \
            const flatjson::fjson cfg{str.c_str(), str.c_str()+str.length()}; \
            if ( !cfg.is_valid() ) { \
                std::string msg{"config file parse error: "}; \
                msg += cfg.error_string(); \
                throw std::runtime_error{msg}; \
            } \
            \
            __CONFIG_CTOR__GENERATE_KEY_CHECKING(#name, keys, cfg, seq) \
            \
            name res{cfg}; \
            \
            ::config_ctor::details::call_after_read_proxy< \
                ::config_ctor::details::has_member_function_after_read<void (name::*)(name &)>::value \
            >::call(res); \
            \
            return res; \
        } \
        static name read(const std::string &fname) { \
            std::ifstream is{fname}; \
            assert(is.good()); \
            return read(is); \
        } \
        \
        static void write(std::ostream &os, const name &cfg) { \
            ::config_ctor::details::call_before_write_proxy< \
                ::config_ctor::details::has_member_function_before_write<void (name::*)(name &)>::value \
            >::call(cfg); \
            \
            os << "{\n"; \
            BOOST_PP_SEQ_FOR_EACH_I( \
                 __CONFIG_CTOR__ENUM_WRITE_MEMBERS \
                ,~ \
                ,seq \
            ) \
            os << "}\n"; \
        } \
        static void write(const std::string &fname, const name &cfg) { \
            std::ofstream os{fname}; \
            assert(os.good()); \
            return write(os, cfg); \
        } \
        \
        std::ostream& operator<< (std::ostream &os) { \
            return dump(os); \
        } \
        std::ostream& dump(std::ostream &os) const { \
            os << "{"; \
            BOOST_PP_SEQ_FOR_EACH_I( \
                 __CONFIG_CTOR__ENUM_MEMBERS \
                ,~ \
                ,seq \
            ) \
            os << "}"; \
            \
            return os; \
        } \
    };

/***************************************************************************/

#define CONSTRUCT_CONFIG(\
     name /* config struct name */ \
    ,seq  /* sequence of vars */ \
    ,...  /* user code*/ \
) \
    __CONFIG_CTOR__GENERATE_STRUCT( \
         name \
        ,BOOST_PP_CAT(__CONFIG_CTOR__WRAP_SEQUENCE_X seq, 0) \
        ,__VA_ARGS__ \
    )

/***************************************************************************/

#ifdef CONFIG_CTOR_HEADER_ONLY
#   include <config-ctor/config-ctor.cpp>
#endif // CONFIG_CTOR_HEADER_ONLY

#endif // __config_ctor__config_ctor_hpp
