
// Copyright (c) 2014-2019 niXman (i dot nixman dog gmail dot com). All
// rights reserved.
//
// This file is part of CONFIG-CTOR(https://github.com/niXman/config-ctor) project.
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
//
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <config-ctor/config-ctor.hpp>

#include <boost/multiprecision/cpp_dec_float.hpp>

#include <iostream>

#ifdef _WIN32
#   include <windows.h>
#endif // _WIN32

/***************************************************************************/

#define DUMP_CONFIG(os, ss, descr) \
    os << __FILE__ << '(' << __LINE__ << ")[" descr "]:" << std::endl; \
    os << ss.str() << std::endl;

#define MY_ENV_TEST(env, exp) { \
    CONSTRUCT_CONFIG( \
        config, \
        (std::string, path) \
    ) \
    std::stringstream ss; \
    ss << "{\"path\":\"" << env << "\"}" << std::endl; \
    config cfg = config::read(ss); \
    assert(cfg.path == exp) ; \
}

/***************************************************************************/

std::string get_user() {
#ifdef _WIN32
    return ::getenv("USERNAME");
#elif defined(__linux__) || defined(__APPLE__)
    return ::getenv("USER");
#endif // _WIN32
}

std::string get_home() {
#ifdef _WIN32
    return ::getenv("USERPROFILE");
#elif defined(__linux__) || defined(__APPLE__)
    return ::getenv("HOME");
#endif // _WIN32
}

std::string get_temp() {
    if (const char *temp = ::getenv("TMPDIR")) {
        return temp;
    } else if (const char *temp = ::getenv("TEMP")) {
        return temp;
    } else if (const char *temp = ::getenv("TMP")) {
        return temp;
    }
    return "/tmp";
}

std::string get_cwd() { return ::getcwd(nullptr, 1024); }
std::string get_pid() { return std::to_string(::getpid()); }

std::string get_proc_path() {
    char buf[1024] = "\0";
#ifdef _WIN32
    ::GetModuleFileName(nullptr, buf, sizeof(buf)-1);
#elif defined(__linux__) || defined(__APPLE__)
    ::readlink("/proc/self/exe", buf, sizeof(buf)-1);
#else
#   error UNKNOWN HOST
#endif

    return buf;
}

std::string get_proc_name() {
    const std::string procpath = get_proc_path();
#ifdef _WIN32
    const std::size_t p = procpath.rfind('\\');
#elif defined(__linux__) || defined(__APPLE__)
    const std::size_t p = procpath.rfind('/');
#else
#   error UNKNOWN HOST
#endif

    return p != std::string::npos ? procpath.substr(p+1) : procpath;
}

/***************************************************************************/

using double_type = boost::multiprecision::number<
    boost::multiprecision::cpp_dec_float<8>
>;

namespace config_ctor {
namespace details {

double_type get_value(
     double_type *
    ,const char *key
    ,const flatjson::fjson &cfg
    ,const char *default_value)
{
    if ( !default_value ) {
        const auto ss = cfg.at(key).to_string();
        return double_type{ss.data()};
    }

    return !cfg.contains(key)
        ? double_type{default_value}
        : double_type{cfg.at(key).to_string().data()}
    ;
}

void write_value(std::ostream &os, const double_type &v) {
    os << v;
}

} // ns details
} // ns config_ctor

int main() {
    {
        CONSTRUCT_CONFIG(
            type,
            (int, i)
            (std::string, s)
        )
        CONSTRUCT_CONFIG(
            config,
            (int, a)
            (float, b)
            (std::string, c)
            (type, t)
            (double_type, d)
        )

        static const int a = 33;
        static const float b = 44.55;
        static const std::string c = "some string";
        static const double_type d{"66.77"};

        const config wcfg{
             a
            ,b
            ,c
            ,type{3, "33"}
            ,d
        };

        std::stringstream ss;
        config::write(ss, wcfg);
        DUMP_CONFIG(std::cout, ss, "dump for nested config-ctor types")

        const config rcfg = config::read(ss);
        assert(rcfg.a == a);
        assert(rcfg.b == b);
        assert(rcfg.c == c);
        assert(rcfg.t.i == 3);
        assert(rcfg.t.s == "33");
        assert(rcfg.d == d);
    }

    //////////////////////////////////////////////// containers test
    {
        static const int i = 3;
        static const std::vector<int> v{0, 1, 2, 3};
        CONSTRUCT_CONFIG(
            config,
            (int, i)
            (std::vector<int>, v)
        )

        const config wcfg{
             i
            ,v
        };

        std::stringstream ss;
        config::write(ss, wcfg);
        DUMP_CONFIG(std::cout, ss, "dump for containers 0")

        const config rcfg = config::read(ss);
        assert(rcfg.i == i);
        assert(rcfg.v == v);
    }
    {
        const int i = 3;
        const std::vector<std::string> v{"0", "1", "2", "3"};
        CONSTRUCT_CONFIG(
            config,
            (int, i)
            (std::vector<std::string>, v)
        )

        const config wcfg{
             i
            ,v
        };

        std::stringstream ss;
        config::write(ss, wcfg);
        DUMP_CONFIG(std::cout, ss, "dump for containers 1")

        const config rcfg = config::read(ss);
        assert(rcfg.i == i);
        assert(rcfg.v == v);
    }
    {
        CONSTRUCT_CONFIG(
            type,
            (int, i)
        )

        const std::vector<type> v{
             flatjson::fjson{R"({"i":0})"}
            ,flatjson::fjson{R"({"i":1})"}
            ,flatjson::fjson{R"({"i":2})"}
            ,flatjson::fjson{R"({"i":3})"}
        };
        CONSTRUCT_CONFIG(
            config,
            (std::vector<type>, v)
        )

        const config wcfg{v};

        std::stringstream ss;
        config::write(ss, wcfg);
        DUMP_CONFIG(std::cout, ss, "dump for containers with config-ctor types")

        const config rcfg = config::read(ss);
        assert(rcfg.v.size() == v.size());
        for ( auto it = rcfg.v.begin(), it2 = v.begin(); it != rcfg.v.end(); ++it, ++it2 ) {
            assert(it->i == it2->i);
        }
    }
    //////////////////////////////////////////////// default value test
    {
        CONSTRUCT_CONFIG(
            config,
            (int, a)
            (bool, b, false)
            (float, c, 22)
            (std::string, d)
            (std::string, e, /path/to/some/file.ext)
            (long, f)
        )

        static const int a = 33;
        static const std::string d = "string";

        std::stringstream ss;
        ss << "{" << std::endl
           << "\"a\":" << a << std::endl
           << ",\"d\":\"" << d << "\"" << std::endl
           << ",\"f\":\"64k\"" << std::endl
           << "}" << std::endl;

        const config rcfg = config::read(ss);
        assert(rcfg.a == a);
        assert(rcfg.b == false);
        assert(rcfg.c == 22);
        assert(rcfg.d == d);
        assert(rcfg.e == "/path/to/some/file.ext");
        assert(rcfg.f == 64*1024);
    }
    //////////////////////////////////////////////// env test
    {
        const std::string user = get_user(); assert(user.size());
//        std::cout << "user=" << user << std::endl;
        const std::string home = get_home(); assert(home.size());
//        std::cout << "home=" << home << std::endl;
        const std::string path = getenv("PATH") ; assert(path.size());
//        std::cout << "path=" << path << std::endl;
        const std::string cwd  = get_cwd()      ; assert(cwd.size());
//        std::cout << "cwd=" << cwd << std::endl;
        const std::string temp = get_temp()     ; assert(temp.size());
//        std::cout << "temp=" << temp << std::endl;
        const std::string pid  = get_pid()      ; assert(pid.size());
//        std::cout << "pid=" << pid << std::endl;
        const std::string procp = get_proc_path(); assert(procp.size());
//        std::cout << "procp=" << procp << std::endl;
        const std::string proc = get_proc_name(); assert(proc.size());
//        std::cout << "proc=" << proc << std::endl;

        // USER
        MY_ENV_TEST("{USER}", user);
        MY_ENV_TEST("/{USER}", "/"+user);
        MY_ENV_TEST("{USER}/", user+"/");
        MY_ENV_TEST("/{USER}/", "/"+user+"/");
        MY_ENV_TEST("/1/{USER}/2", "/1/"+user+"/2");

        // HOME
        MY_ENV_TEST("{HOME}", home);
        MY_ENV_TEST("/{HOME}", "/"+home);
        MY_ENV_TEST("{HOME}/", home+"/");
        MY_ENV_TEST("/{HOME}/", "/"+home+"/");
        MY_ENV_TEST("/1/{HOME}/2", "/1/"+home+"/2");

        // TEMP
        MY_ENV_TEST("{TEMP}", temp);
        MY_ENV_TEST("/{TEMP}", "/"+temp);
        MY_ENV_TEST("{TEMP}/", temp+"/");
        MY_ENV_TEST("/{TEMP}/", "/"+temp+"/");
        MY_ENV_TEST("/1/{TEMP}/2", "/1/"+temp+"/2");

        // CWD
        MY_ENV_TEST("{CWD}", cwd);
        MY_ENV_TEST("/{CWD}", "/"+cwd);
        MY_ENV_TEST("{CWD}/", cwd+"/");
        MY_ENV_TEST("/{CWD}/", "/"+cwd+"/");
        MY_ENV_TEST("/1/{CWD}/2", "/1/"+cwd+"/2");

        // PID
        MY_ENV_TEST("{PID}", pid);
        MY_ENV_TEST("/{PID}", "/"+pid);
        MY_ENV_TEST("{PID}/", pid+"/");
        MY_ENV_TEST("/{PID}/", "/"+pid+"/");
        MY_ENV_TEST("/1/{PID}/2", "/1/"+pid+"/2");

        // PATH
        MY_ENV_TEST("{PATH}", path);
        MY_ENV_TEST("/{PATH}", "/"+path);
        MY_ENV_TEST("{PATH}/", path+"/");
        MY_ENV_TEST("/{PATH}/", "/"+path+"/");
        MY_ENV_TEST("/1/{PATH}/2", "/1/"+path+"/2");

        // PROC
        MY_ENV_TEST("{PROC}", proc);
        MY_ENV_TEST("/{PROC}", "/"+proc);
        MY_ENV_TEST("{PROC}/", proc+"/");
        MY_ENV_TEST("/{PROC}/", "/"+proc+"/");
        MY_ENV_TEST("/1/{PROC}/2", "/1/"+proc+"/2");

        // PROCPATH
        MY_ENV_TEST("{PROCPATH}", procp);
        MY_ENV_TEST("/{PROCPATH}", "/"+procp);
        MY_ENV_TEST("{PROCPATH}/", procp+"/");
        MY_ENV_TEST("/{PROCPATH}/", "/"+procp+"/");
        MY_ENV_TEST("/1/{PROCPATH}/2", "/1/"+procp+"/2");

        // GETENV()
        MY_ENV_TEST("/1/{GETENV(USER)}/2", "/1/"+user+"/2");
        MY_ENV_TEST("/1/{GETENV(USER, default user)}/2", "/1/"+user+"/2");
        MY_ENV_TEST("/1/{GETENV(BADUSER)}/2", "/1/<NULL>/2");
        MY_ENV_TEST("/1/{GETENV(BADUSER, default user)}/2", "/1/default user/2");
    }
    //////////////////////////////////////////////// user code test
    {
        CONSTRUCT_CONFIG(
            config
            ,
            (int, a)
            (float, b)
            (std::string, c)
            (bool, c_not_empty)
            ,
            void after_read(config &cfg) {
                std::cout << "after_read()" << std::endl;
                cfg.c_not_empty = !cfg.c.empty();
            }
            void before_write(config &cfg) {
                std::cout << "before_write()" << std::endl;
                cfg.c_not_empty = !cfg.c.empty();
            }
        )

        static const int a = 33;
        static const float b = 44.55;
        static const std::string c = "some string";

        const config wcfg{a, b, c, false};

        std::stringstream ss;
        config::write(ss, wcfg);
        DUMP_CONFIG(std::cout, ss, "dump for \"after_read()\"/\"before_write()\"")

        config rcfg = config::read(ss);
        assert(rcfg.a == a);
        assert(rcfg.b == b);
        assert(rcfg.c == c);
    }

    return EXIT_SUCCESS;
}

/***************************************************************************/
